[{"content":"This article was published at https://karnwong.me\nTo deploy a web application, there are many ways to go about it. I could spin up a bare VM and set up the environment manually. To make things easier, I could have package the app into docker image. But this still means I have to \u0026ldquo;update\u0026rdquo; the app manually if I add changes to it.\nThings would be super cool if: after I push the changes to master branch, the app would be deployed automatically. In order to achieve this, I could use AWS ECS task to deploy the app, and add CI/CD to it (because this is 2022 after all).\nAnd things would be even better if I don\u0026rsquo;t have to set up the infra manually every time I want to deploy an app, enters terraform!\nBelow are minimal ecs task with fargate backend setup ðŸ˜Ž. Repo here.\nUpdated 2022-09-02\nNotes: you might need to set up autoscaling on LB connections per target. Also this example contains two target tracking policies for the same service. Race conditions can result in undesirable scaling issues. Thanks John Mille!\nTask definition This is equivalent to docker-compose.yaml\nresource \u0026#34;aws_cloudwatch_log_group\u0026#34; \u0026#34;this\u0026#34; { retention_in_days = 14 name = \u0026#34;/aws/ecs/${var.service_name}\u0026#34; } resource \u0026#34;aws_ecs_task_definition\u0026#34; \u0026#34;this\u0026#34; { family = var.service_name network_mode = \u0026#34;awsvpc\u0026#34; requires_compatibilities = [\u0026#34;FARGATE\u0026#34;] cpu = 256 memory = 512 execution_role_arn = var.task_role task_role_arn = var.task_role container_definitions = jsonencode( [ { name = var.service_name image = var.image_uri essential = true environment = [] portMappings = [ { protocol = \u0026#34;tcp\u0026#34; containerPort = 80 hostPort = 80 } ] logConfiguration = { logDriver = \u0026#34;awslogs\u0026#34; options = { awslogs-group = aws_cloudwatch_log_group.this.name awslogs-region = var.aws_region awslogs-stream-prefix = \u0026#34;ecs\u0026#34; } } } ] ) } resource \u0026#34;aws_ecs_service\u0026#34; \u0026#34;this\u0026#34; { name = var.service_name cluster = var.ecs_cluster_id task_definition = aws_ecs_task_definition.this.arn desired_count = 1 deployment_minimum_healthy_percent = 50 deployment_maximum_percent = 200 launch_type = \u0026#34;FARGATE\u0026#34; scheduling_strategy = \u0026#34;REPLICA\u0026#34; network_configuration { security_groups = [var.alb_id] subnets = var.subnet_id assign_public_ip = true } load_balancer { target_group_arn = aws_alb_target_group.this.arn container_name = var.service_name container_port = 80 } } SSL certificate resource \u0026#34;aws_acm_certificate\u0026#34; \u0026#34;this\u0026#34; { domain_name = var.domain_name validation_method = \u0026#34;DNS\u0026#34; lifecycle { create_before_destroy = true } tags = { Name = var.domain_name } } Load balancer resource \u0026#34;aws_lb\u0026#34; \u0026#34;this\u0026#34; { name = var.service_name internal = false load_balancer_type = \u0026#34;application\u0026#34; security_groups = [var.alb_id] subnets = var.subnet_id idle_timeout = 3600 enable_deletion_protection = true } resource \u0026#34;aws_alb_target_group\u0026#34; \u0026#34;this\u0026#34; { name = var.service_name port = 80 protocol = \u0026#34;HTTP\u0026#34; vpc_id = var.vpc_id target_type = \u0026#34;ip\u0026#34; health_check { healthy_threshold = \u0026#34;3\u0026#34; interval = \u0026#34;30\u0026#34; protocol = \u0026#34;HTTP\u0026#34; matcher = \u0026#34;200\u0026#34; timeout = \u0026#34;3\u0026#34; path = var.health_check_path unhealthy_threshold = \u0026#34;2\u0026#34; } } resource \u0026#34;aws_alb_listener\u0026#34; \u0026#34;http\u0026#34; { load_balancer_arn = aws_lb.this.id port = 80 protocol = \u0026#34;HTTP\u0026#34; default_action { type = \u0026#34;forward\u0026#34; target_group_arn = aws_alb_target_group.this.arn } } resource \u0026#34;aws_alb_listener\u0026#34; \u0026#34;https\u0026#34; { load_balancer_arn = aws_lb.this.id port = 443 protocol = \u0026#34;HTTPS\u0026#34; ssl_policy = \u0026#34;ELBSecurityPolicy-2016-08\u0026#34; certificate_arn = aws_acm_certificate.this.arn default_action { target_group_arn = aws_alb_target_group.this.id type = \u0026#34;forward\u0026#34; } } Autoscaling Because we are using cloud, and I love taking advantage of dynamic resources allocation.\nresource \u0026#34;aws_appautoscaling_target\u0026#34; \u0026#34;this\u0026#34; { max_capacity = 2 min_capacity = 1 resource_id = \u0026#34;service/${var.ecs_cluster_name}/${aws_ecs_service.this.name}\u0026#34; scalable_dimension = \u0026#34;ecs:service:DesiredCount\u0026#34; service_namespace = \u0026#34;ecs\u0026#34; } resource \u0026#34;aws_appautoscaling_policy\u0026#34; \u0026#34;memory\u0026#34; { name = \u0026#34;memory-autoscaling\u0026#34; policy_type = \u0026#34;TargetTrackingScaling\u0026#34; resource_id = aws_appautoscaling_target.this.resource_id scalable_dimension = aws_appautoscaling_target.this.scalable_dimension service_namespace = aws_appautoscaling_target.this.service_namespace target_tracking_scaling_policy_configuration { predefined_metric_specification { predefined_metric_type = \u0026#34;ECSServiceAverageMemoryUtilization\u0026#34; } target_value = 40 } } resource \u0026#34;aws_appautoscaling_policy\u0026#34; \u0026#34;cpu\u0026#34; { name = \u0026#34;cpu-autoscaling\u0026#34; policy_type = \u0026#34;TargetTrackingScaling\u0026#34; resource_id = aws_appautoscaling_target.this.resource_id scalable_dimension = aws_appautoscaling_target.this.scalable_dimension service_namespace = aws_appautoscaling_target.this.service_namespace target_tracking_scaling_policy_configuration { predefined_metric_specification { predefined_metric_type = \u0026#34;ECSServiceAverageCPUUtilization\u0026#34; } target_value = 60 } } ","permalink":"https://devbaygroup.github.io/posts/2022-08-26-minimal-ecs-task-with-fargate-backend/","summary":"This article was published at https://karnwong.me\nTo deploy a web application, there are many ways to go about it. I could spin up a bare VM and set up the environment manually. To make things easier, I could have package the app into docker image. But this still means I have to \u0026ldquo;update\u0026rdquo; the app manually if I add changes to it.\nThings would be super cool if: after I push the changes to master branch, the app would be deployed automatically.","title":"Minimal ECS task with fargate backend"}]